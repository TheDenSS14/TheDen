// SPDX-FileCopyrightText: 2024 DEATHB4DEFEAT <77995199+DEATHB4DEFEAT@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 VMSolidus <evilexecutive@gmail.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Rosycup <178287475+Rosycup@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 portfiend <109661617+portfiend@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 sleepyyapril <123355664+sleepyyapril@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Linq;
using Content.Client.Administration.UI;
using Content.Client.Lobby;
using Content.Client.Lobby.UI;
using Content.Client.Players.PlayTimeTracking;
using Content.Client.UserInterface.Controls;
using Content.Shared.CCVar;
using Content.Shared.Clothing.Components;
using Content.Shared.Clothing.Loadouts.Prototypes;
using Content.Shared.Clothing.Loadouts.Systems;
using Content.Shared.Customization.Systems;
using Content.Shared.Preferences;
using Content.Shared.Roles;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Map;
using Robust.Shared.Prototypes;

namespace Content.Client._DEN.Lobby.UI.Loadouts;

[GenerateTypedNameReferences]
public sealed partial class LoadoutsPanel : BoxContainer
{
    [Dependency] private readonly IConfigurationManager _configuration = default!;
    [Dependency] private readonly IEntityManager _entity = default!;
    [Dependency] private readonly IEntitySystemManager _entitySystem = default!;
    [Dependency] private readonly JobRequirementsManager _jobRequirements = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    private readonly CharacterRequirementsSystem _characterRequirements;
    private readonly LobbyUIController _lobbyUI;

    private HashSet<LoadoutPreferenceSelector> _preferenceSelectors = new();
    private Dictionary<LoadoutPrototype, bool> _loadoutData = new();
    private Dictionary<string, EntityUid> _loadoutDummies = new();
    private Dictionary<Button, ConfirmationData> _confirmationData = new();
    private Dictionary<ProtoId<LoadoutCategoryPrototype>, BoxContainer> _categoryTabs = new();
    private Dictionary<ProtoId<LoadoutPrototype>, LoadoutPreferenceSelector> _selectorLookup = new();
    private Dictionary<string, LoadoutPreference> _profilePreferenceLookup = new();

    private HumanoidCharacterProfile? _profile;
    private EntityUid? _dummy;
    private bool _showUnusable = false;
    private int _maxPoints = 0;

    public event Action<HashSet<LoadoutPrototype>>? OnRemoveUnusableAction;
    public event Action<LoadoutPreference, bool>? OnLoadoutSelectedAction;

    // TODO: This probably should be broken up into even smaller classes

    public LoadoutsPanel()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _lobbyUI = UserInterfaceManager.GetUIController<LobbyUIController>();
        _characterRequirements = _entitySystem.GetEntitySystem<CharacterRequirementsSystem>();

        LoadoutsShowUnusableButton.OnToggled += args => SetShowUnusable(args.Pressed);
        LoadoutsRemoveUnusableButton.OnPressed += _ => TryRemoveUnusableLoadouts();
    }

    public void SetProfile(HumanoidCharacterProfile? profile)
    {
        _profile = profile;
    }

    public void SetPreviewDummy(EntityUid dummy)
    {
        _dummy = dummy;
    }

    private void SetShowUnusable(bool unusable)
    {
        _showUnusable = unusable;
        UpdateLoadouts();
    }

    private void TryRemoveUnusableLoadouts()
    {
        if (!AdminUIHelpers.TryConfirm(LoadoutsRemoveUnusableButton, _confirmationData))
            return;

        OnRemoveUnusableAction?.Invoke(GetUnusableSelectedLoadouts());
    }

    /// <summary>
    ///     Updates all UI controls that depend on the currently selected loadout preferences of this profile.
    ///     This includes: loadout selector states, the points remaining bar, and the number of unusable loadouts.
    /// </summary>
    private void UpdateLoadoutPreferences()
    {
        UpdatePreferenceSelectors();
        UpdatePointsRemainingBar();
        UpdateUnusableLoadoutCount();
        LoadoutsTabs.UpdateTabMerging();
    }

    /// <summary>
    ///     Recalculates and updates the "remaining points" progress bar and label.
    /// </summary>
    private void UpdatePointsRemainingBar()
    {
        _maxPoints = _configuration.GetCVar(CCVars.GameLoadoutsPoints);
        var points = _maxPoints;

        if (_profile?.LoadoutPreferences != null)
            foreach (var pref in _profile.LoadoutPreferences)
            {
                if (_selectorLookup.TryGetValue(pref.LoadoutName, out var selector)
                    && selector.Preference.Selected)
                    points -= selector.Loadout.Cost;
            }

        LoadoutPointsLabel.Text = Loc.GetString("humanoid-profile-editor-loadouts-points-label",
            ("points", points),
            ("max", _maxPoints));
        LoadoutPointsBar.MaxValue = _maxPoints;
        LoadoutPointsBar.Value = points;
    }

    /// <summary>
    ///     Recalculates the amount of unusable loadouts and updates the unusable loadout count in
    ///     the "Remove Unusable Loadouts" button label.
    /// </summary>
    private void UpdateUnusableLoadoutCount()
    {
        var unusableCount = GetUnusableSelectedLoadouts().Count();

        LoadoutsRemoveUnusableButton.Text = Loc.GetString(
            "humanoid-profile-editor-loadouts-remove-unusable-button",
            ("count", unusableCount)
        );

        AdminUIHelpers.RemoveConfirm(LoadoutsRemoveUnusableButton, _confirmationData);
    }

    /// <summary>
    ///     Updates all loadout selectors at once by updating their selected status,
    ///     wearability status, and whether they should be hidden (due to being unusable).
    /// </summary>
    private void UpdatePreferenceSelectors()
    {
        _profilePreferenceLookup = _profile?.LoadoutPreferences?
            .ToDictionary(lp => lp.LoadoutName)
            ?? new Dictionary<string, LoadoutPreference>();

        foreach (var selector in _preferenceSelectors)
        {
            SyncSelectorToProfile(selector);

            if (_loadoutData.TryGetValue(selector.Loadout, out var usable))
                UpdatePreferenceSelector(selector, usable);
        }
    }

    /// <summary>
    ///     Updates loadout data, adds missing tabs and loadout selectors, and reloads
    ///     loadout preference UIs.
    ///
    ///     TODO: Separate this for efficiency.
    /// </summary>
    /// <param name="reload">Whether this should be a full reload of the loadout UI - starting from scratch with no tabs or loadout selectors.</param>
    public void UpdateLoadouts(bool reload = false)
    {
        if (reload)
            ClearLoadoutTabs();

        var mainJob = _lobbyUI.GetPreferredJob(_profile
            ?? HumanoidCharacterProfile.DefaultWithSpecies())
            ?? new JobPrototype();
        var profile = _profile ?? HumanoidCharacterProfile.DefaultWithSpecies();

        ReloadLoadoutData(mainJob, profile);

        if (_loadoutData.Count == 0)
        {
            BuildNoLoadoutsInterface();
            return;
        }

        BuildLoadoutTabs(mainJob, profile);
        UpdateLoadoutPreferences();
    }

    /// <summary>
    ///     Updates visual properties of a loadout selector button. The visibility of a button
    ///     depends on whether it is usable and/or if "show usable" is enabled.
    ///     This also updates "wearability" status - for example, harpies cannot wear shoes.
    /// </summary>
    /// <param name="selector">The loadout selector button.</param>
    /// <param name="usable">Whether this loadout is considered "usable" (all requirements fulfilled)</param>
    private void UpdatePreferenceSelector(LoadoutPreferenceSelector selector, bool usable)
    {
        selector.Valid = usable;
        selector.ShowUnusable = _showUnusable;
        selector.Wearable = PreferenceIsWearable(selector);
    }

    /// <summary>
    ///     Whether or not the loadout in this loadout selector is considered "wearable". It is unwearable
    ///     if ANY of the items in the loadout cannot be worn by the character.
    ///     TODO: This might need to be inverted?
    /// </summary>
    /// <param name="selector">The loadout selector button.</param>
    /// <returns>Whether or not the loadout is wearable by the current profile.</returns>
    private bool PreferenceIsWearable(LoadoutPreferenceSelector selector)
    {
        if (_dummy == null)
            return false;

        foreach (var (item, index) in selector.Loadout.Items.Select((item, index) => (item, index)))
        {
            var key = $"{selector.Loadout.ID}_{index}";
            var entity = EnsureLoadoutDummy(item, key);

            if (_entity.HasComponent<ClothingComponent>(entity)
                && !_characterRequirements.CanEntityWearItem(_dummy.Value, entity))
                return false;
        }

        return true;
    }

    /// <summary>
    ///     Repopulates the `_loadoutData` by mapping LoadoutPrototypes to whether or not they are
    ///     "usable" (fulfilling all requirements) by the given profile.
    /// </summary>
    /// <param name="mainJob">The preferred job this profile uses.</param>
    /// <param name="profile">The profile that will be checked against loadout requirements.</param>
    private void ReloadLoadoutData(JobPrototype mainJob, HumanoidCharacterProfile profile)
    {
        _loadoutData.Clear();

        var playtimeTrackers = _jobRequirements.GetRawPlayTimeTrackers();
        var whitelisted = _jobRequirements.IsWhitelisted();

        foreach (var loadoutProto in _prototype.EnumeratePrototypes<LoadoutPrototype>())
        {
            var usable = _characterRequirements.CheckRequirementsValid(
                loadoutProto.Requirements,
                mainJob,
                profile,
                playtimeTrackers,
                whitelisted,
                loadoutProto,
                _entity,
                _prototype,
                _configuration,
                out _
            );

            _loadoutData.Add(loadoutProto, usable);
        }
    }

    /// <summary>
    ///     Creates the interface that is displayed if there are no loadouts at all.
    /// </summary>
    private void BuildNoLoadoutsInterface()
    {
        var noLoadoutsLabel = new Label
        {
            Text = Loc.GetString("humanoid-profile-editor-loadouts-no-loadouts")
        };

        LoadoutsTabs.AddTab(noLoadoutsLabel, Loc.GetString("loadout-category-Uncategorized"));
    }

    /// <summary>
    ///     Initializes tab containers and selectors for each loadout category recursively, including subcategories.
    /// </summary>
    /// <param name="mainJob">The preferred job this profile uses.</param>
    /// <param name="profile">The profile that will be checked against loadout requirements.</param>
    private void BuildLoadoutTabs(JobPrototype mainJob, HumanoidCharacterProfile profile)
    {
        if (!_categoryTabs.TryGetValue("Uncategorized", out var uncategorizedTab))
            uncategorizedTab = AddTabToContainer("Uncategorized", LoadoutsTabs);

        var loadoutCategories = _prototype.EnumeratePrototypes<LoadoutCategoryPrototype>();
        var rootCategories = loadoutCategories
            .Where(c => c.Root)
            .OrderBy(c => Loc.GetString($"loadout-category-{c.ID}"))
            .ToList();

        var categoryTree = CreateTree(rootCategories);
        var categories = new Dictionary<string, object>();

        foreach (var (key, value) in categoryTree)
            categories.Add(key, value);

        BuildCategoryContainer(categories, LoadoutsTabs);
        PopulateCategoryTabs(mainJob, profile, uncategorizedTab);
        HideEmptyTabs(loadoutCategories.ToList());
    }

    /// <summary>
    ///     Deletes all tabs and loadout selectors.
    /// </summary>
    private void ClearLoadoutTabs()
    {
        foreach (var tab in LoadoutsTabs.Tabs)
            LoadoutsTabs.RemoveTab(tab);

        foreach (var uid in _loadoutDummies)
            _entity.QueueDeleteEntity(uid.Value);

        _categoryTabs.Clear();
        _preferenceSelectors.Clear();
        _selectorLookup.Clear();
    }

    /// <summary>
    ///     Creates a new loadout selector for a given loadout.
    /// </summary>
    /// <param name="loadout">The loadout prototype corresponding to this selector.</param>
    /// <param name="mainJob">The preferred job this profile uses.</param>
    /// <param name="profile">The profile that will be checked against loadout requirements.</param>
    /// <param name="usable">Whether or not this loadout is usable.</param>
    /// <returns>A loadout selector button.</returns>
    private LoadoutPreferenceSelector BuildNewSelector(LoadoutPrototype loadout,
        JobPrototype mainJob,
        HumanoidCharacterProfile profile,
        bool usable)
    {
        var newSelector = new LoadoutPreferenceSelector(
            loadout,
            mainJob,
            profile,
            ref _loadoutDummies,
            _entity,
            _prototype,
            _configuration,
            _characterRequirements,
            _jobRequirements)
        {
            Preference = new(loadout.ID)
        };

        UpdatePreferenceSelector(newSelector, usable);
        AddLoadoutSelector(newSelector);

        return newSelector;
    }

    /// <summary>
    ///     Recursively constructs a tab container and subcategory tabs for a given category.
    /// </summary>
    /// <param name="tree">A recursive table of sub-categories and loadouts prototypes.</param>
    /// <param name="parent">The control that this container should be added to.</param>
    private void BuildCategoryContainer(Dictionary<string, object> tree, NeoTabContainer parent)
    {
        foreach (var (key, value) in tree)
        {
            if (parent.Contents.Any(c => c.Name == key))
                continue;

            if (value is List<LoadoutPrototype>)
                AddTabToContainer(key, parent);
            else
            {
                var category = new NeoTabContainer
                {
                    Name = key,
                    HorizontalExpand = true,
                    VerticalExpand = true,
                    SeparatorMargin = new Thickness(0),
                };

                parent.AddTab(category, Loc.GetString($"loadout-category-{key}"));
                _categoryTabs.Add(key, category);
                BuildCategoryContainer((Dictionary<string, object>) value, category);
            }
        }
    }

    /// <summary>
    /// Iterates over every loadout selector and inserts them into the associated loadout category tab.
    /// </summary>
    /// <param name="mainJob">The highest job of the character.</param>
    /// <param name="profile">The HumanoidCharacterProfile data associated with the character.</param>
    /// <param name="uncategorizedTab">The container for uncategorized loadout items.</param>
    private void PopulateCategoryTabs(JobPrototype mainJob,
        HumanoidCharacterProfile profile,
        BoxContainer uncategorizedTab)
    {
        var orderedLoadouts = _loadoutData
            .OrderBy(l => l.Key.ID)
            .ToList();

        _profilePreferenceLookup = _profile?.LoadoutPreferences?
            .ToDictionary(lp => lp.LoadoutName)
            ?? new Dictionary<string, LoadoutPreference>();

        foreach (var (loadout, usable) in orderedLoadouts)
        {
            if (_selectorLookup.TryGetValue(loadout.ID, out var selector))
            {
                SyncSelectorToProfile(selector);
                UpdatePreferenceSelector(selector, usable);
                continue;
            }

            var newSelector = BuildNewSelector(loadout, mainJob, profile, usable);
            var categoryContainer = _categoryTabs.GetValueOrDefault(loadout.Category, uncategorizedTab);
            var contentContainer = categoryContainer.Children.First().Children.First();
            contentContainer.AddChild(newSelector);
        }
    }

    /// <summary>
    ///     Creates a new tab container representing a loadout (sub)category.
    /// </summary>
    /// <param name="name">The name of this tab container.</param>
    /// <param name="parent">This tab container is added as a new tab to this NeoTabContainer.</param>
    /// <returns></returns>
    private BoxContainer AddTabToContainer(string name, NeoTabContainer parent)
    {
        var tabContent = new BoxContainer
        {
            Orientation = LayoutOrientation.Vertical,
            HorizontalExpand = true,
            VerticalExpand = true,
        };

        var scroll = new ScrollContainer
        {
            HScrollEnabled = false,
            HorizontalExpand = true,
            VerticalExpand = true,
            Children = { tabContent },
        };

        var tab = new BoxContainer
        {
            Name = name,
            Orientation = LayoutOrientation.Vertical,
            HorizontalExpand = true,
            VerticalExpand = true,
            Children = { scroll },
        };

        _categoryTabs.Add(name, tab);
        parent.AddTab(tab, Loc.GetString($"loadout-category-{name}"));
        return tab;
    }

    /// <summary>
    ///     Adds a loadout selector to the relevant data tables, and binds the click event that
    ///     allows it to select/deselect loadouts.
    /// </summary>
    /// <param name="selector">The selector button to add.</param>
    private void AddLoadoutSelector(LoadoutPreferenceSelector selector)
    {
        _preferenceSelectors.Add(selector);
        _selectorLookup.Add(selector.Loadout.ID, selector);

        selector.PreferenceChanged += preference =>
        {
            var isSelected = preference.Selected;
            var loadout = selector.Loadout;
            var selected = isSelected
                ? ValidateSelection(-loadout.Cost, isSelected)
                : ValidateSelection(loadout.Cost, isSelected);

            OnLoadoutSelectedAction?.Invoke(preference, selected);
        };
    }

    /// <summary>
    ///     Creates a recursive data structure representing all loadout categories and sub-categories.
    /// </summary>
    /// <param name="loadoutCategories">List of loadout categories to add to this branch of the tree.</param>
    /// <returns></returns>
    private Dictionary<string, object> CreateTree(List<LoadoutCategoryPrototype> loadoutCategories)
    {
        var tree = new Dictionary<string, object>();
        foreach (var category in loadoutCategories)
        {
            if (tree.ContainsKey(category.ID))
                continue;

            var subCategories = category.SubCategories
                .Where(subCategory => !tree.ContainsKey(subCategory))
                .ToList();

            if (subCategories.Count == 0)
            {
                tree.Add(category.ID, new List<LoadoutPrototype>());
                continue;
            }

            var subCategoryTree = CreateTree(subCategories
                .Select(c => _prototype.Index(c))
                .ToList());
            tree.Add(category.ID, subCategoryTree);
        }

        return tree;
    }

    /// <summary>
    ///     Hides all category tabs that have no buttons in them.
    /// </summary>
    /// <param name="categories">A list of all categories that may be hidden.</param>
    private void HideEmptyTabs(List<LoadoutCategoryPrototype> categories)
    {
        foreach (var category in categories)
        {
            if (!_categoryTabs.TryGetValue(category.ID, out var tab))
                continue;

            var contentContainer = tab.Children
                .FirstOrDefault()?
                .Children.FirstOrDefault()?
                .Children;

            var hasContent = contentContainer?.Any() ?? false;

            if (GetTopTabContainer(tab) is NeoTabContainer topContainer)
                topContainer.SetTabVisible(tab, hasContent);

            if (tab.Parent?.Parent is NeoTabContainer parentTab)
                HideEmptyTabs(GetSubcategoriesFromTabs(parentTab));
        }
    }

    /// <summary>
    ///     Updates a loadout selector's preference with the currently loaded profile's preference.
    ///     This also sets the selection status of the loadout selector.
    /// </summary>
    /// <param name="selector">The selector button to update.</param>
    private void SyncSelectorToProfile(LoadoutPreferenceSelector selector)
    {
        _profilePreferenceLookup.TryGetValue(selector.Loadout.ID, out var preference);
        var selected = preference?.Selected ?? false;
        preference ??= selector.Preference;

        selector.Preference = new(
            preference.LoadoutName,
            preference.CustomName,
            preference.CustomDescription,
            preference.CustomColorTint,
            preference.CustomHeirloom)
        {
            Selected = selected
        };
    }

    /// <summary>
    ///     Creates a "dummy entity" for an item in a loadout. Not to be confused with the loadout icon!!
    ///     These dummy entitires are used to check against requirements.
    /// </summary>
    /// <param name="itemProto">The entity prototype for the loadout item.</param>
    /// <param name="key">A unique key for caching this entity.</param>
    /// <returns>The ID of the dummy entity.</returns>
    private EntityUid EnsureLoadoutDummy(EntProtoId itemProto, string key)
    {
        if (_loadoutDummies.TryGetValue(key, out var entity)
            && _entity.GetComponent<MetaDataComponent>(entity).EntityPrototype!.ID == itemProto)
            return entity;

        entity = _entity.SpawnEntity(itemProto, MapCoordinates.Nullspace);
        _loadoutDummies[key] = entity;
        return entity;
    }

    /// <summary>
    ///     Checks whether a loadout can be selected/deselected while remaining within the bounds of point costs.
    /// </summary>
    /// <param name="cost">The cost of the loadout.</param>
    /// <param name="isSelected">Whether or not the button itself is selected.</param>
    /// <returns>The "real" selection status to maintain within the point bounds.</returns>
    private bool ValidateSelection(int cost, bool isSelected)
    {
        var testPoints = LoadoutPointsBar.Value + cost;
        return isSelected ? testPoints >= 0 : testPoints < 0;
    }

    /// <summary>
    ///     Whether or not this loadout is wearable and follows all requirements.
    /// </summary>
    /// <param name="loadout">The loadout to check.</param>
    /// <param name="isValid">Whether or not this loadout follows character requirements.</param>
    /// <returns>If this loadout is usable or not.</returns>
    private bool IsLoadoutUnusable(LoadoutPrototype loadout)
    {
        return !_loadoutData.TryGetValue(loadout, out var valid)
            || !valid
            || _selectorLookup.TryGetValue(loadout.ID, out var selector)
            && !selector.Wearable;
    }

    /// <summary>
    ///     Searches for the topmost tab container.
    /// </summary>
    /// <param name="tab">The tab to search for the topmost ancestor.</param>
    /// <returns>The topmost tab container.</returns>
    private NeoTabContainer? GetTopTabContainer(Control tab)
    {
        return tab.Parent?.Parent?.Parent?.Parent as NeoTabContainer;
    }

    /// <summary>
    ///     Gets a list of subcategories of a NeoTabContainer from its contents.
    /// </summary>
    /// <param name="parent">The NeoTabContainer to use.</param>
    /// <returns>A list of LoadoutCategoryPrototype subcategories.</returns>
    private List<LoadoutCategoryPrototype> GetSubcategoriesFromTabs(NeoTabContainer parent)
    {
        var categories = new List<LoadoutCategoryPrototype>();

        foreach (var control in parent.Contents)
        {
            if (control.Name == null) continue;
            if (_prototype.TryIndex<LoadoutCategoryPrototype>(control.Name, out var proto))
                categories.Add(proto);
        }

        return categories;
    }

    /// <summary>
    ///     Creates a HashSet of all currently-selected unusable loadouts.
    /// </summary>
    /// <returns>A HashSet of all currently-selected unusable loadouts.</returns>
    private HashSet<LoadoutPrototype> GetUnusableSelectedLoadouts()
    {
        var unusableLoadouts = new HashSet<LoadoutPrototype>();

        foreach (var (id, pref) in _profilePreferenceLookup)
        {
            if (!pref.Selected)
                continue;

            if (_prototype.TryIndex<LoadoutPrototype>(id, out var proto)
                && IsLoadoutUnusable(proto))
                unusableLoadouts.Add(proto);
        }

        return unusableLoadouts;
    }
}
