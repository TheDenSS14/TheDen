using System.Linq;
using Content.Client._DEN.Lobby.UI.Loadouts;
using Content.Client.Resources;
using Content.Shared.CCVar;
using Content.Shared.Clothing.Loadouts.Prototypes;
using Content.Shared.Clothing.Loadouts.Systems;
using Content.Shared.Preferences;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;

namespace Content.Client._DEN.Lobby.UI.Controls;

[GenerateTypedNameReferences]
public sealed partial class LoadoutsItemListPanel : BoxContainer
{
    [Dependency] private readonly IConfigurationManager _configuration = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IResourceCache _resourceCache = default!;

    /// <summary>
    ///     Fired when points remaining are recalculated.
    /// </summary>
    public event Action<int>? OnPointsUpdaated;

    /// <summary>
    ///     Fired when a loadout preference changes.
    /// </summary>
    public event Action<LoadoutPreference>? OnPreferenceChanged;

    /// <summary>
    ///     Fired when a loadout item's "customize" button is clicked.
    /// </summary>
    public event Action<LoadoutPreference>? OnCustomizeToggled;

    // Dependencies
    // Events
    // Constants
    // Data Lists
    // Private Class Members
    // Public Variables
    // Dynamic Private Variables

    private const string CategoryNameFontPath = "/Fonts/NotoSans/NotoSans-Bold.ttf";
    private const int CategoryNameFontSize = 16;
    private Font CategoryNameFont => _resourceCache.GetFont(CategoryNameFontPath, CategoryNameFontSize);

    private Dictionary<string, LoadoutPreference> _profilePreferenceLookup = new();
    private Dictionary<ProtoId<LoadoutCategoryPrototype>, BoxContainer> _categoryLists = new();
    private Dictionary<LoadoutPrototype, LoadoutItemButton> _loadoutButtons = new();
    private ProtoId<LoadoutCategoryPrototype>? _currentCategory = null;

    private HumanoidCharacterProfile? _profile = null;
    private EntityUid? _characterDummy = null;
    private int MaxPoints => _configuration.GetCVar(CCVars.GameLoadoutsPoints);
    private int _points = 0;

    public LoadoutsItemListPanel()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        CategoryTitle.FontOverride = CategoryNameFont;
        PopulateLoadouts();
    }

    public void SetProfile(HumanoidCharacterProfile? profile)
    {
        _profile = profile;
        _profilePreferenceLookup = _profile?.LoadoutPreferences
            .ToDictionary(lp => lp.LoadoutName)
            ?? new();

        RecalculatePoints();
        UpdatePreferences();
    }

    public void SetCharacterDummy(EntityUid? dummy)
    {
        _characterDummy = dummy;
    }

    public void PopulateLoadouts(bool reset = false)
    {
        var stopwatch = new Stopwatch();
        stopwatch.Start();

        try
        {

            if (reset)
            {
                CategoryContents.RemoveAllChildren();
                _categoryLists.Clear();
                _loadoutButtons.Clear();
            }

            var groups = _prototype.EnumeratePrototypes<LoadoutPrototype>()
                .OrderBy(l => l.ID)
                .GroupBy(l => l.Category);

            foreach (var group in groups)
            {
                var category = group.Key;

                if (!_categoryLists.TryGetValue(category, out var listBox))
                {
                    listBox = CreateLoadoutListBox(category);
                    CategoryContents.AddChild(listBox);
                    _categoryLists.Add(category, listBox);
                }

                foreach (var loadout in group)
                {
                    if (_loadoutButtons.TryGetValue(loadout, out var _))
                        continue;

                    var button = new LoadoutItemButton(loadout);
                    button.OnPreferenceChanged += p => OnButtonPreferenceChanged(button, p);
                    button.OnCustomizeToggled += _ => OnCustomizeToggled?.Invoke(button.Preference);

                    listBox.AddChild(button);
                    _loadoutButtons.Add(loadout, button);
                }
            }

        }
        finally
        {
            Logger.GetSawmill("LoadoutsItemListPanel").Debug($"All loadout items loaded in {stopwatch.Elapsed.TotalMilliseconds}ms");
        }
    }

    private BoxContainer CreateLoadoutListBox(ProtoId<LoadoutCategoryPrototype> categoryId)
    {
        var listBox = new BoxContainer()
        {
            Orientation = LayoutOrientation.Vertical,
            HorizontalExpand = true,
            HorizontalAlignment = HAlignment.Stretch,
            Name = "ItemCategory" + categoryId,
            Visible = false,
        };

        return listBox;
    }

    private void UpdatePreferences()
    {
        var profilePrefs = _profile?.LoadoutPreferences ?? new();
        var selectedButtons = _loadoutButtons.Values
            .Where(b => b.Pressed);

        foreach (var button in selectedButtons)
        {
            if (!_profilePreferenceLookup.TryGetValue(button.Loadout.ID, out var _))
                button.SetSelected(false);
        }

        foreach (var pref in profilePrefs)
        {
            if (pref != null
                && _prototype.TryIndex<LoadoutPrototype>(pref.LoadoutName, out var loadout)
                && _loadoutButtons.TryGetValue(loadout, out var button))
                button.Preference = pref;
        }
    }

    private void RecalculatePoints()
    {
        _points = MaxPoints;

        if (_profile?.LoadoutPreferences != null)
        {
            _points -= _profile.LoadoutPreferences
                .Where(p => p.Selected)
                .Select(p => _prototype.Index<LoadoutPrototype>(p.LoadoutName))
                .Sum(l => l.Cost);
        }

        OnPointsUpdaated?.Invoke(_points);
    }

    private void OnButtonPreferenceChanged(LoadoutItemButton button, LoadoutPreference preference)
    {
        var loadout = button.Loadout;
        var currSelected = _profilePreferenceLookup.TryGetValue(preference.LoadoutName, out _);
        var newSelected = button.Pressed;

        // We're changing the selected state of the button.
        if (currSelected != newSelected)
        {
            var shouldSelect = ValidateSelection(loadout, newSelected);
            if (shouldSelect != newSelected)
            {
                button.SetSelected(shouldSelect);

                // If newSelected != currSelected AND newSelected != shouldSelect,
                // then currSelected == shouldSelect. This means that our preference selection status
                // ultimately did not change. This is why we're returning here.
                return;
            }
        }

        OnPreferenceChanged?.Invoke(preference);
    }

    private bool ValidateSelection(LoadoutPrototype loadout, bool attemptSelected)
    {
        var cost = loadout.Cost;

        // If we're trying to select it; allow selection if the new point value would not be negative.
        // (I.e: Has enough points to select)
        if (attemptSelected)
            return _points - cost >= 0;

        // If we're trying to deselect it; force selection if the new point value would be negative.
        // (I.e: Has enough points to deselect)
        // ...Shouldn't happen unless you're making loadouts with negative point costs for some reason.
        return _points + cost < 0;
    }

    public void SetVisibleCategory(ProtoId<LoadoutCategoryPrototype>? category)
    {
        if (_currentCategory == category)
            return;

        var titleText = string.Empty;

        // Hide previous box
        if (_currentCategory != null
            && _categoryLists.TryGetValue(_currentCategory.Value, out var oldBox))
            oldBox.Visible = false;

        _currentCategory = category;

        // Show new box
        if (_currentCategory != null)
        {
            titleText = LoadoutsTab.GetCategoryName(_currentCategory.Value);
            if (_categoryLists.TryGetValue(_currentCategory.Value, out var listBox))
                listBox.Visible = true;
        }

        CategoryTitle.Text = titleText;
    }

    public EntityUid? GetPreviewEntity(LoadoutPrototype loadout)
    {
        if (_loadoutButtons.TryGetValue(loadout, out var button))
            return button.PreviewEntity;

        return null;
    }
}
